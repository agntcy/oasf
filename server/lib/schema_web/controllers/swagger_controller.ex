# Copyright AGNTCY Contributors (https://github.com/agntcy)
# SPDX-License-Identifier: Apache-2.0

defmodule SchemaWeb.SwaggerController do
  @moduledoc """
  Version-aware Swagger UI controller that serves Swagger UI with version-specific API paths.
  """

  use SchemaWeb, :controller

  alias Schema
  alias SchemaWeb.Router

  @doc """
  Serves Swagger UI with version-specific API paths.
  Handles both /doc (default version) and /{version}/doc routes.
  """
  def swagger_ui(conn, params) do
    # Extract version from path or use default
    version = extract_version(conn, params)

    # Generate version-specific swagger.json
    swagger_json = generate_versioned_swagger_json(version)

    # Serve Swagger UI with modified swagger.json
    serve_swagger_ui(conn, swagger_json)
  end

  defp extract_version(conn, params) do
    # Check if version is in path params (from router)
    case Map.get(params, "version") do
      nil ->
        # Check request path directly
        path_segments = String.split(conn.request_path, "/", trim: true)

        case path_segments do
          [version, "doc"] -> version
          ["doc"] -> Schema.version()
          _ -> Schema.version()
        end

      version ->
        version
    end
  end

  defp generate_versioned_swagger_json(version) do
    # Read base swagger.json file generated by PhoenixSwagger at compile time
    # PhoenixSwagger generates this file during compilation
    swagger_file_path =
      Path.join([Application.app_dir(:schema_server, "priv/static"), "swagger.json"])

    base_swagger =
      case File.read(swagger_file_path) do
        {:ok, content} ->
          Jason.decode!(content)

        {:error, reason} ->
          # Log error and return minimal swagger structure
          require Logger

          Logger.warning(
            "Could not read swagger.json from #{swagger_file_path}: #{inspect(reason)}"
          )

          # Return minimal structure - this should not happen in production
          %{
            "swagger" => "2.0",
            "info" => Router.swagger_info() |> Map.get(:info, %{}),
            "paths" => %{},
            "definitions" => %{}
          }
      end

    # Update all API paths to include version prefix
    updated_paths = update_paths_with_version(base_swagger["paths"] || %{}, version)

    # Update servers/basePath if present
    updated_swagger =
      base_swagger
      |> Map.put("paths", updated_paths)
      |> update_servers(version)

    updated_swagger
  end

  defp update_paths_with_version(paths, version) when is_map(paths) do
    Enum.reduce(paths, %{}, fn {path_key, path_value}, acc ->
      # Prepend version to path if it starts with /api/, /schema/, /export/, or /sample/
      updated_path =
        cond do
          String.starts_with?(path_key, "/api/") ->
            # Don't add version if it's already there
            if String.starts_with?(path_key, "/api/#{version}/") do
              path_key
            else
              "/api/#{version}" <> String.trim_leading(path_key, "/api")
            end

          String.starts_with?(path_key, "/schema/") ->
            # Don't add version if it's already there
            if String.starts_with?(path_key, "/schema/#{version}/") do
              path_key
            else
              "/schema/#{version}" <> String.trim_leading(path_key, "/schema")
            end

          String.starts_with?(path_key, "/export/") ->
            # Don't add version if it's already there
            if String.starts_with?(path_key, "/export/#{version}/") do
              path_key
            else
              "/export/#{version}" <> String.trim_leading(path_key, "/export")
            end

          String.starts_with?(path_key, "/sample/") ->
            # Don't add version if it's already there
            if String.starts_with?(path_key, "/sample/#{version}/") do
              path_key
            else
              "/sample/#{version}" <> String.trim_leading(path_key, "/sample")
            end

          true ->
            path_key
        end

      Map.put(acc, updated_path, path_value)
    end)
  end

  defp update_servers(swagger, version) do
    # Update servers array if present (OpenAPI 3.0)
    if Map.has_key?(swagger, "servers") do
      servers =
        swagger["servers"]
        |> Enum.map(fn server ->
          if is_map(server) and Map.has_key?(server, "url") do
            url = server["url"]
            # Update URL to include version for /api, /schema, /export, /sample paths
            updated_url =
              url
              |> update_url_with_version("/api", version)
              |> update_url_with_version("/schema", version)
              |> update_url_with_version("/export", version)
              |> update_url_with_version("/sample", version)

            Map.put(server, "url", updated_url)
          else
            server
          end
        end)

      Map.put(swagger, "servers", servers)
    else
      # For Swagger 2.0, update basePath if present
      if Map.has_key?(swagger, "basePath") do
        base_path = swagger["basePath"]

        updated_base_path =
          base_path
          |> update_url_with_version("/api", version)
          |> update_url_with_version("/schema", version)
          |> update_url_with_version("/export", version)
          |> update_url_with_version("/sample", version)

        Map.put(swagger, "basePath", updated_base_path)
      else
        swagger
      end
    end
  end

  defp update_url_with_version(url, prefix, version) do
    versioned_prefix = "#{prefix}/#{version}"

    cond do
      # Already has version prefix, skip
      String.contains?(url, versioned_prefix) ->
        url

      # Contains prefix but not versioned, add version
      String.contains?(url, prefix) ->
        String.replace(url, ~r{#{prefix}(/|$)}, "#{versioned_prefix}/")

      # Doesn't contain prefix, leave as is
      true ->
        url
    end
  end

  defp serve_swagger_ui(conn, swagger_json) do
    # Generate HTML for Swagger UI
    html_content = generate_swagger_ui_html(swagger_json)

    conn
    |> put_resp_content_type("text/html")
    |> send_resp(200, html_content)
  end

  defp generate_swagger_ui_html(swagger_json) do
    # Embed swagger.json in HTML and configure Swagger UI
    # Use a script tag with type="application/json" for safe embedding
    swagger_json_str = Jason.encode!(swagger_json)

    """
    <!DOCTYPE html>
    <html>
    <head>
      <title>OASF Schema API Documentation</title>
      <link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui.css" />
      <style>
        html { box-sizing: border-box; overflow: -moz-scrollbars-vertical; overflow-y: scroll; }
        *, *:before, *:after { box-sizing: inherit; }
        body { margin:0; background: #fafafa; }
      </style>
    </head>
    <body>
      <div id="swagger-ui"></div>
      <script type="application/json" id="swagger-json">#{swagger_json_str}</script>
      <script src="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui-bundle.js"></script>
      <script src="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui-standalone-preset.js"></script>
      <script>
        window.onload = function() {
          const swaggerJsonElement = document.getElementById('swagger-json');
          const swaggerJson = JSON.parse(swaggerJsonElement.textContent);
          
          // Configure Swagger UI
          const ui = SwaggerUIBundle({
            spec: swaggerJson,
            dom_id: '#swagger-ui',
            deepLinking: true,
            presets: [
              SwaggerUIBundle.presets.apis,
              SwaggerUIStandalonePreset
            ],
            plugins: [
              SwaggerUIBundle.plugins.DownloadUrl
            ],
            layout: "StandaloneLayout"
          });
        };
      </script>
    </body>
    </html>
    """
  end
end
